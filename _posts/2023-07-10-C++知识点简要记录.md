---
layout: post
title: "C++知识点简要记录"
date: 2023-07-10
excerpt: "用来复习"
tags: [cpp]
comments: true










---

* toc
{:toc}




以下内容是自己近端时间复习C++时，对于一些知识点的简要记录，目的不是为了规范，只是让自己想到哪个点的时候能够回想起来，所以格式比较乱，目前会一直更新



# 1.字符

字符和字符串的问题  /0



# 2.字符串复制

str1 = "China";

str1 = str2;是违法的，得用strcpy

char str1[10] = "one123";这是定义的时候初始化，合法

str1 = "12312";这是赋值，非法



# 3.strcpy

strcpy复制后，有效值在第一个\0上



# 4.strcmp

strcmp一般用于比是否相等

先比asicll码，再比\0

不能这样比字符串

if(str1 == str2)因为是两个地址比较

得这样写if(strcmp(str1,str2) == 0)



# 5.strlen

strlen得到实际长度，不包括\0

每个汉字占两个字节



# 6.外部变量

C语言中函数只能返回一个值

全局变量得定义在使用之前

//extern int a;   int func() {    int b = a;    return b; } int a = 1;

记得外部变量说明不能被初始化，外部变量说明可以多次声明



# 7.变量的划分方式

从作用域分：局部变量和全局变量

从生存期分：静态和动态

局部static 不能被其他函数引用，在静态存储区，编译时赋初值，没有的话默认为0



# 8.全局变量

全局变量的跨文件引用

有两个cpp文件

一个定义int a;

则在另一个cpp里面用他的话得在#include 这个下面加上extern int a;，一般写到这，毕竟引用完你下面才能用a

这样说明a已经在其他地方定义过了，不用再分内存给它

那如果我们不想让其他cpp引用全局变量的话

则static int a;这样的话，就算在另外一个文件extern int a;也会报错的，报无法解析外部符号的错误

并且这样写还有一个优点，就是你如果在两个cpp里面同时定义一个全局变量a，比如都有int a;这是编不过的

除非static int a，这就说明自己的源文件用自己定义的全局变量，互不影响



# 9.static

在函数之前用static，这个函数只能本文件使用



# 10.宏定义

## 10.1不带参数的

\#define #undef 替换

\#define PI 3.14 宏名一般用大写

字符串内的字符即使和宏名一样也不替换



## 10.2带参数

\#define Sub(a,b) a-b

int result = Sub(3,2) 所以就为1

注意

\#define PI 3.14

\#define S(r) PI*r*r

result = S(1+5)

本意是3.14*6*6，但实际是PI\*1+5*1+5

所以加括号

\#define S(r) PI\*(r)*(r)

但注意宏名和带参数之间的括号不能有空格，也就是S和(r)之间不能有空格

如果有空格了就像#define S (r) PI\*(r)*(r)

则代表S替换为(r) PI\*(r)*(r)



## 10.3宏和函数的不用

函数调用是在运行到这个函数的时候才执行，涉及到分内存等，而宏是在编译阶段，并且它也不分配内存

宏的参数没有类型的说法，比如3.14，没有类型，不是说什么int还是double

宏展开只占用编译时间，不占用运行时间，而函数调用占用运行时间（分配内存，传递参数，执行函数体。返回值等）

宏还能替代比较复杂的

\#define MAX(x, y) (x)>(y)?(x):(y)

int result = MAX(3,4);

还能替代多行语句。末尾的"\"用来代表下一行代码和本行代码本是同一行

\#define MACROTEST do{\

printf("test\n"); \

} while(0);



# 11.文件包含

其中头文件一旦改动，就会把包含他的cpp都重新编译一下

因为本质上#include "test.h"是那文件替换，你把头文件动了，那他将来替换到其他cpp里面的源代码也是都动了，所以得重新编译



# 12.条件编译

一般情况下，在生成可执行文件的过程中，源程序文件中的所有代码都参加编译，但有时候希望对其中的一部分内容只在满足一定条件下才进行编译，也就是对一部分内容指定编译的条件，也有的时候，希望当满足某条件时对一组语句进行编译，而当条件不满足时编译另外一组语句，这都叫条件编译

条件编译用的比较频繁，尤其是写一些跨操作系统平台的代码，例如既在window也在linux编译运行，但程序中有些特殊的系统调用函数只能在window下编译 运行或者在linux下编译运行，此时就有必要使用条件编译了

有这几种形式

1)

\#define DEBUG 1

这下面是在main里面

\#ifdef DEBUG

 程序段1

\#else

 程序段2

\#endif

2)

\#ifndef DEBUG

 程序段1

\#else

 程序段2

\#endif

3)

\#define MYPI 1

\#if DEBUG

 程序段1

\#else

 程序段2

\#endif

例子

\#if _WIN32

prinf("是window平台");

\#elif __Linux__

prinf("是linux平台");

\#else

//其他平台

\#endif

其中_WIN32，__Linux__这都会在各自的平台，系统自己定义，不用自己定义的

# 13.直接和间接访问

直接访问：直接通过变量名找到

间接访问：

int i =5;

mypoint = &i;

这个mypoint是用来存i的地址的，但是它本身在内存也有地址的，所以也是占内存的，一般在x86占4字节，在x64占8字节

这个mypoint成为指针变量，专门用来存另一个变量的地址

指针就是一个地址（地址用数字表示）

# 14.指针变量

指针变量是存其他变量地址的便阿玲，也叫该指针变量指向某某变量，如这里的mypoint指向i

变量的指针，就是变量的地址，变量mypoint中保存着变量i的地址，因此变量mypoint就是指向变量i的指针变量

指针变量在定义时，会在定义的语句中引入一个“*”，表示“这是一个指针变量”

int * a1;定义一个指针变量，这个指针变量指向整型变量，指针变量前面有个*，这个是和普通变量最明显的区别

现在要让一个指针变量指向一个整型变量，用赋值语句可以到

a1 = &i;

注意：定义指针变量时，前面有*，但是使用指针变量时，前面没有*，所以指针变量名是a1，而不是*a1

int * a1 = & i;这属于定义时候初始化，现在a1指向i

等价于

int * a1;

a1 = &i;

*这个指针运算符不用于定义变量指针的场合时，代表的是它所指向的变量

比如上面的

i = 10;

int * a1 = & i;

printf("%d", * a1); // 10 ，*a1代表i

再提一嘴

(*a1)++等同于i++

\*a1++等同于*(a1++) 

a1++是什么意思呢，我们知道a1就是存的i的地址，那让i的地址++，而由于i是个整型，所以a1++相当于a1要跳过4字节，所以a1不再指向i了，而是指向i后面的内存

那\*(a1++) = 5是什么意思，首先这是将a1所指向的内容赋值为5(因为++是先用后加，所以此时相当于是*a1 = 5)，因为a1开始指向i变量，所以是让i变量的值为5；其次让a1自加1，也就是a1++,导致a1指向i后面的地址，如果i的起始地址是1000，那a1指向的地址现在为1004

指针变量做参数，可以间接在函数汇总改变指针变量所指向的变量的值，从而达到在被调用函数内改变外界变量值的效果

```cpp 
void swap(int* pdest1, int* pdest2)
{    
    int temp; temp = *pdest1;      
    *pdest1 = *pdest2;  //*pdest1实际就是pdest1所指向的变量，也就是a    		*pdest2 = temp; //*pdest2实际就是pdest2所指向的变量，也就是b 
} 

int main() 
{    
    int a = 5, b = 6;    
    int* p1, * p2; 
    p1 = &a; p2 = &b;    
    if (a < b)    
    {   
        swap(p1, p2);    
    }    
    cout << a << b;    
    return 0; 
}
```

记住有一个错误

int * p;

 *p = 5

这是错的，因为p里面还没有存任何地址，也就是说他没有指向任何一个变量，那这个5往哪里存它都不知道

所以这样改就对了

int * p; 

int a; 

p = &a; 

*p = 5;

这样p的内存里面存的就是a的地址了，*p也就是a了，也就是a=5

# 15.指向数组元素的指针

int a[2];

a[0] = 1; a[1] = 2;

int *p;

p = &a[0];//把a[0]元素的地址赋给指针变量p，即p指向数组第0号元素

因为数组名也就是数组首地址，所以

p = &a[0];和p = a;是一样的

定义指针变量时候也可以赋初值，这两行等价

int * p = &a[0];

int * p = a;

