---
layout: post
title: "C++知识点简要记录"
date: 2023-07-10
excerpt: "用来复习"
tags: [cpp]
comments: true










---

* toc
{:toc}




以下内容是自己近端时间复习C++时，对于一些知识点的简要记录，目的不是为了规范，只是让自己想到哪个点的时候能够回想起来，所以格式比较乱，目前会一直更新



# 1.字符

字符和字符串的问题  /0



# 2.字符串复制

str1 = "China";

str1 = str2;是违法的，得用strcpy

char str1[10] = "one123";这是定义的时候初始化，合法

str1 = "12312";这是赋值，非法



# 3.strcpy

strcpy复制后，有效值在第一个\0上



# 4.strcmp

strcmp一般用于比是否相等

先比asicll码，再比\0

不能这样比字符串

if(str1 == str2)因为是两个地址比较

得这样写if(strcmp(str1,str2) == 0)



# 5.strlen

strlen得到实际长度，不包括\0

每个汉字占两个字节



# 6.外部变量

C语言中函数只能返回一个值

全局变量得定义在使用之前

//extern int a;   int func() {    int b = a;    return b; } int a = 1;

记得外部变量说明不能被初始化，外部变量说明可以多次声明



# 7.变量的划分方式

从作用域分：局部变量和全局变量

从生存期分：静态和动态

局部static 不能被其他函数引用，在静态存储区，编译时赋初值，没有的话默认为0



# 8.全局变量

全局变量的跨文件引用

有两个cpp文件

一个定义int a;

则在另一个cpp里面用他的话得在#include 这个下面加上extern int a;，一般写到这，毕竟引用完你下面才能用a

这样说明a已经在其他地方定义过了，不用再分内存给它

那如果我们不想让其他cpp引用全局变量的话

则static int a;这样的话，就算在另外一个文件extern int a;也会报错的，报无法解析外部符号的错误

并且这样写还有一个优点，就是你如果在两个cpp里面同时定义一个全局变量a，比如都有int a;这是编不过的

除非static int a，这就说明自己的源文件用自己定义的全局变量，互不影响



# 9.static

在函数之前用static，这个函数只能本文件使用



# 10.宏定义

## 10.1不带参数的

\#define #undef 替换

\#define PI 3.14 宏名一般用大写

字符串内的字符即使和宏名一样也不替换



## 10.2带参数

\#define Sub(a,b) a-b

int result = Sub(3,2) 所以就为1

注意

\#define PI 3.14

\#define S(r) PI*r*r

result = S(1+5)

本意是3.14*6*6，但实际是PI\*1+5*1+5

所以加括号

\#define S(r) PI\*(r)*(r)

但注意宏名和带参数之间的括号不能有空格，也就是S和(r)之间不能有空格

如果有空格了就像#define S (r) PI\*(r)*(r)

则代表S替换为(r) PI\*(r)*(r)



## 10.3宏和函数的不用

函数调用是在运行到这个函数的时候才执行，涉及到分内存等，而宏是在编译阶段，并且它也不分配内存

宏的参数没有类型的说法，比如3.14，没有类型，不是说什么int还是double

宏展开只占用编译时间，不占用运行时间，而函数调用占用运行时间（分配内存，传递参数，执行函数体。返回值等）

宏还能替代比较复杂的

\#define MAX(x, y) (x)>(y)?(x):(y)

int result = MAX(3,4);

还能替代多行语句。末尾的"\"用来代表下一行代码和本行代码本是同一行

\#define MACROTEST do{\

printf("test\n"); \

} while(0);



# 11.文件包含

其中头文件一旦改动，就会把包含他的cpp都重新编译一下

因为本质上#include "test.h"是那文件替换，你把头文件动了，那他将来替换到其他cpp里面的源代码也是都动了，所以得重新编译



# 12.条件编译

一般情况下，在生成可执行文件的过程中，源程序文件中的所有代码都参加编译，但有时候希望对其中的一部分内容只在满足一定条件下才进行编译，也就是对一部分内容指定编译的条件，也有的时候，希望当满足某条件时对一组语句进行编译，而当条件不满足时编译另外一组语句，这都叫条件编译

条件编译用的比较频繁，尤其是写一些跨操作系统平台的代码，例如既在window也在linux编译运行，但程序中有些特殊的系统调用函数只能在window下编译 运行或者在linux下编译运行，此时就有必要使用条件编译了

有这几种形式

1)

\#define DEBUG 1

这下面是在main里面

\#ifdef DEBUG

 程序段1

\#else

 程序段2

\#endif

2)

\#ifndef DEBUG

 程序段1

\#else

 程序段2

\#endif

3)

\#define MYPI 1

\#if DEBUG

 程序段1

\#else

 程序段2

\#endif

例子

\#if _WIN32

prinf("是window平台");

\#elif __Linux__

prinf("是linux平台");

\#else

//其他平台

\#endif

其中_WIN32，__Linux__这都会在各自的平台，系统自己定义，不用自己定义的

# 13.直接和间接访问

直接访问：直接通过变量名找到

间接访问：

int i =5;

mypoint = &i;

这个mypoint是用来存i的地址的，但是它本身在内存也有地址的，所以也是占内存的，一般在x86占4字节，在x64占8字节

这个mypoint成为指针变量，专门用来存另一个变量的地址

指针就是一个地址（地址用数字表示）

# 14.指针变量

指针变量是存其他变量地址的便阿玲，也叫该指针变量指向某某变量，如这里的mypoint指向i

变量的指针，就是变量的地址，变量mypoint中保存着变量i的地址，因此变量mypoint就是指向变量i的指针变量

指针变量在定义时，会在定义的语句中引入一个“*”，表示“这是一个指针变量”

int * a1;定义一个指针变量，这个指针变量指向整型变量，指针变量前面有个*，这个是和普通变量最明显的区别

现在要让一个指针变量指向一个整型变量，用赋值语句可以到

a1 = &i;

注意：定义指针变量时，前面有\*，但是使用指针变量时，前面没有\*，所以指针变量名是a1，而不是*a1

int * a1 = & i;这属于定义时候初始化，现在a1指向i

等价于

int * a1;

a1 = &i;

*这个指针运算符不用于定义变量指针的场合时，代表的是它所指向的变量

比如上面的

i = 10;

int * a1 = & i;

printf("%d", * a1); // 10 ，*a1代表i

再提一嘴

(*a1)++等同于i++

\*a1++等同于*(a1++) 

a1++是什么意思呢，我们知道a1就是存的i的地址，那让i的地址++，而由于i是个整型，所以a1++相当于a1要跳过4字节，所以a1不再指向i了，而是指向i后面的内存

那\*(a1++) = 5是什么意思，首先这是将a1所指向的内容赋值为5(因为++是先用后加，所以此时相当于是*a1 = 5)，因为a1开始指向i变量，所以是让i变量的值为5；其次让a1自加1，也就是a1++,导致a1指向i后面的地址，如果i的起始地址是1000，那a1指向的地址现在为1004

指针变量做参数，可以间接在函数汇总改变指针变量所指向的变量的值，从而达到在被调用函数内改变外界变量值的效果

```cpp 
void swap(int* pdest1, int* pdest2)
{    
    int temp; temp = *pdest1;      
    *pdest1 = *pdest2;  //*pdest1实际就是pdest1所指向的变量，也就是a    		*pdest2 = temp; //*pdest2实际就是pdest2所指向的变量，也就是b 
} 

int main() 
{    
    int a = 5, b = 6;    
    int* p1, * p2; 
    p1 = &a; p2 = &b;    
    if (a < b)    
    {   
        swap(p1, p2);    
    }    
    cout << a << b;    
    return 0; 
}
```

记住有一个错误

int * p;

 *p = 5

这是错的，因为p里面还没有存任何地址，也就是说他没有指向任何一个变量，那这个5往哪里存它都不知道

所以这样改就对了

int * p; 

int a; 

p = &a; 

*p = 5;

这样p的内存里面存的就是a的地址了，*p也就是a了，也就是a=5

# 15.指向数组元素的指针

int a[2];

a[0] = 1; a[1] = 2;

int *p;

p = &a[0];//把a[0]元素的地址赋给指针变量p，即p指向数组第0号元素

因为数组名也就是数组首地址，所以

p = &a[0];和p = a;是一样的

定义指针变量时候也可以赋初值，这两行等价

int * p = &a[0];

int * p = a;

```cpp
int a[2]
a[0] = 1; a[1] = 2;
int *p;
p = &a[0];
//引用一个数组元素，目前由于以下几种方法：
a[i],p[i],*[p+i],*(a+i)
```



# 16.指针数组和数组指针

int * p[10]这是指针数组，首先这是个数组，数组里有10个元素，每个元素都是一个指针，每个元素里面是这样的int*

数组指针int (*p)[10] ，表明的是这个是个指向数组的指针，那么该指针变量存储的地址必须是数组的首地址，p是一个指针，指向一个int[10]的数组，每个数组元素是一个int类型的变量

[数组指针和指针数组的区别 - hongcha_717 - 博客园 (cnblogs.com)](https://www.cnblogs.com/hongcha717/archive/2010/10/24/1859780.html)



# 17.字符串

字符串表现形式可以用字符数组表示

char test1[] = "aaaa";

char test2[] = "aaaa";

这是两个内存

也可以用字符指针实现表示

const char * test1 = "aaaa";

const char * test2 = "aaaa";

这是两个指针，但aaaa只占一个内存空间

```cpp
//这个例子难理解
	char a[] = "aaaa";
    char b[100];
    char* c1, * c2; 
    int i;
    c1 = a;
    c2 = b;
    for (;*c1 != '\0'; c1++, c2++)
    {
        *c2 = *c1;
    }
    *c2 = '\0';
    cout << a << endl;
    cout << b << endl;
    return 0;
```

# 18.字符指针变量和字符数组

char str[100] = "aaa";//定义时候初始化

这样写就不行

char str[100];

str = "aaa"; 

修改成这样才可以

strcpy(str, "aaa");

但像字符指针的操作是可以的

const char * a;

a = "aaa";

这是因为aaa是字符串常量，在内存中是有固定地址的，这行只是让字符指针a指向这个地址而已

指针变量的值是可以变的，也就是指针指向的位置可以发生改变，例如

const char*a = "I love China!";

a = a + 7; //原来指向字符“I“，这里跳过7字节，整好指向China

printf("%s",a);//China!

但是数组名虽然代表数组首地址，但是其值不能改变

char a[] = "I love China!";

a = a + 7; //这是错的，因为数组名代表的数组首地址是不能发生改变的

# 19.用函数指针调用函数

```cpp
int max(int x, int y)
{
    if(x > y)
        return x;
    return y;
}

int main()
{
    int c;
    int (*p)(int x, int y);
    p = max;
    c = (*p)(5,19);//等价于c = max(5,19);
    cout << c ; //19
}
```

如果函数指针变量的定义写成了 int * p(int x, int y)，那就说明了：int *表示这个函数的返回值是指向整型变量的指针

上面这一大段代码，看p = max的地址时，发现不一样，其实p保存的才是函数真正的入口地址，VS只是会维护一张表，把max入口地址表保存到表格里，调用的时候才会去取

但是其实你如果输出max的话，就会看到真实地址了

# 20.指向指针的指针

char ** p 定义一个指向“字符串指针变量”的指针变量

# 21.指针数组作为main函数参数

int main(int argc, char * argv[])  第二个参数是个指针数组

调试看，可以看到这个指针数组的长度是1，并且内容就是可执行文件的完整路径文件名

argc是个数字目前是1

有两种方法可以给argv传入参数

![image-20230802154028566](F:\ZYH\qingfenglan.github.io\images\2023-07-10-C++知识点简要记录\image-20230802154028566.png)

![image-20230802154034921](F:\ZYH\qingfenglan.github.io\images\2023-07-10-C++知识点简要记录\image-20230802154034921.png)

# 22.结构体指针

```cpp
struct student {
    string name;
    int age;
};

int main()
{
    struct student stu;
    struct student* ps;
    ps = &stu;
    stu.name = "zyuh";
    cout << (*ps).name << endl;
    ps->age = 10;
     注意一个是->一个是.

}
```

# 23.共用体

内存是最大的，不能同时定义所有的参数，他们的起始地址一样，可以相互覆盖，占用相同的内存，写的形式和结构体一样

# 24.枚举类型

枚举会根据定义的顺序给赋值，第一个是0等等

```cpp
enum color{
    Red,
    Blue
};

enum color Mycolor;
cout << Red //输出是0

//这样是错的
enum color mycolor1
mycolor1 = 1000;
//但这样是对的
mycolor1 = (enum color)1000;
cout << mycolor1 //输出为1000，说明枚举值和整型是互通的
```

# 25.typedef

typedef是定义新的类型名而不是用来定义变量的

typedef int AAA;相当于AAA就是int

AAA a,b,c定义了三个int型变量

也可以来定义结构体

typedef struct date{

int data;

}BBB;

BBB birthday;定义了一个结构体

BBB * p这是一个指向结构体类型的指针

typedef int NUM[100] // 定义NUM为整型数据类型

NUM n; // 定义n为整型数组变量，原来要这样定义int n[100];

typedef char * CCC;

CCC p,q;//之前的话要这样定义 char * p,q

```cpp
总结一下怎么用typedef
1）写出常规的整型变量定义方法
int n[100];
2)将变量名n替换成自己想用的类型名
int NUM[100];
3)在前面加上typedef
typedef int NUM[100];
3)这三步完成后就可以用typedef定义变量了
NUM n;

注意事项：
习惯把typedef定义的名字写成大写，以辨识与C语言本身的int，char等的区别
typedef是定义新的类型名而不是用来定义变量的
typedef是编译时处理的

编译阶段：
预处理：#define #include # ifdef
编译：词法和语法的分析，目标代码的生成，优化typedef
汇编：产生.o(.obj)目标文件
```

# 26.fgetc

fgetc的缺点，如果文本里真有一个-1的话，就会提前结束，所以用feof替代，这是看文件当前位置的指针是否指到文件末尾

# 27.文件操作

```cpp
FILE* fp = fopen("config.txt", "r");
    if (!fp)
    {
        printf("文件打开失败\n");
    }
    else
    {
        char LineBuf[1024];
        while (!feof(fp))
        {
            LineBuf[0] = 0;
            if (fgets(LineBuf, sizeof(LineBuf) - 1, fp) == NULL)
            {
                continue;
            }if (LineBuf[0] == '\0')
            {
                continue;
            }
        lblprocstring:
            if (strlen(LineBuf) > 0)
            {
                if (LineBuf[strlen(LineBuf) - 1] == 10 || LineBuf[strlen(LineBuf) - 1] == 13) {
                    LineBuf[strlen(LineBuf) - 1] = 0;
                    goto lblprocstring;
                }
            }
            if (strlen(LineBuf) <= 0)
            {
                continue;
            }
            printf("%s\n", LineBuf);
        }
        fclose(fp);
    }
```

# 28.保存到文件中的结构体，字节对齐

对于要保存到文件中的结构体，结构体成员中不要出现指针类型成员变量，因为它所指向的内存地址很可能失效，一旦引用了失效的地址会导致程序运行崩溃

```cpp
struct stu {
    char name[30];
    int age;
    double score;
};
```

字节对齐这个问题和编译器有关，像这个结构体，有30+4+8=42个字节，但是在window上用VS的话你看他长度的话是48字节，因为window自动搞成8的整数倍，linux用gcc则是4的整数倍，你再linux上看他是44字节

如果把 这个结构体写入一个文件中，那在window生成后是48字节，再去linux打开时读出来是44字节，显然读出来的数据肯定出错，解决的办法是，定义结构体之前就用"#pragma pack(1)"设置结构体对齐方式是1字节对齐，按1字节对齐的意思就是告诉编译器不要去对齐，实际是多少字节就是多少字节，如果想要恢复默认的字节对齐方式，在定义结构体之后，可以使用"#pragma pack()"取消刚才的设置的对齐，这样不管是什么操作系统，读这个结构体都是42字节

修改后就是这样子

```cpp
#pragma pack(1)
struct stu {
    char name[30];
    int age;
    double score;
};
#pragma pack()
```

# 29.w,r,wb,rb的区别

如果想要文件原封不动的一样，就用加b的

# 30.上面全是C语言的,下面则开始进入C++

# 31.C++文件的后缀名

不同后缀名是因为不同的编译器，.c .cpp .cc .cxx

.hpp是把定义和实现放在一个文件里，有效的减少编译的次数

# 32.<<结合问题

int i =3;

cout << i-- << i-- //输出是23  先用右边的

<<到底是左结合还是右结合，和编译器有关，不同的编译器结果不同，所以避免一行代码多次改变一个变量的值

# 33.int赋值

int a =3

可以写成int a{3}

这样写的好处在哪里呢

int abc = 3.5f编译时候没问题，但执行会发现，3.5的小数部分被截断，所以abc的值是3

int abc{3.5f}，就会在编译时都报错，提前拦截可能的误截断

当然int abc(123)也一样

# 34.auto

auto自动类型推断发生在编译期，所以使用auto不会造成程序运行时的效率降低

# 35.头文件防卫式声明

头文件he34.ad.h有个定义是 int a = 8;

头文件head2.h有个定义是 int b = 5;

主源文件cpp需要用到这两个变量

\#include "head.h"

\#include "head2.h"

int main

{

 cout << a << endl;

 cout << b << endl;

}

现在这个代码没问题

但是因为一些原因head2.h里面需要包含head.h，所以现在head2.h内容是

\#include "head.h"

int b = 5;

这时候编译就会出错了，重定义错误，这是因为现在源文件里面有这个内容：

\#include "head.h"

\#include "head2.h"

展开后就是

 int a = 8;

 int a = 8;

 int b = 5;

a被定义了两次，所以重定义错误

并且像这样的也会重定义错误

\#include "head.h"

\#include "head.h"

怎么解决呢？

首先改造head.h

\#ifndef \_\_HEAD\_\_

\#define \_\_HEAD\_\_

int a = 8;

\#endif

再改造head2.h

\#ifdef \_\_HEAD2\_\_

\#define \_\_HEAD2\_\_

\#include "head.h"

int b = 5;

说明下，每一个头文件的ifndef后面的定义名字都不一样，不能重名

好了现在修改后编译可以运行了

因为用了#ifndef #define #endif的组合，避免了头文件中的内容被多次#include

例如当head.h第一次被#include到cpp里时，#ifndef \_\_HEAD\_\_成立，所以下面的两行代码被#include到cpp里面

\#define \__HEAD__

int a = 8;

但是假如第二次再head.h被#include到cpp里面，#ifndef \_\_HEAD\_\_条件不成立，因为现在前面已经有了#define \__HEAD__，所以这个head.h的内容不被#include到cpp里面，也就避免了重定义错误

所以写头文件的时候，要习惯性在文件头部添加#ifndef #define，在文件末尾添加#endif，这也就是头文件防卫式声明

# 36.引用

引用是为变量起得别名，定义引用不占用内存

int a = 3;

int& b = a;

b = 5;

这是对的

但是像这种是错的

int& aaa;

int& bbb = 10; 

因为定义引用时，必须进行初始化

int a = 3;

int &b  = a;//引用，是&在=左边

int * p = &a;//取地址符，&在=右边

在看引用作为形参

```cpp
void func(int &ta, int &tb)
{
    ta = 4;
    tb = 5;
}
int main()
{
    int a = 13;
    int b =14;
    func(a, b);
    cout << a << " " << b << std::endl;
    return 0;
}
```

# 37.const和constexpr

# 38.避免数据的复制

int v[]{12, 13, 14, 15}

for(auto x : v)

{

cout << x << endl;

}

相当于把v里每个元素都复制到x中

那怎么修改呢

for(auto &x : v)只用修改成这样，用引用的方式，就可以避免数据的复制

一般说，一个容器只要内部支持begin和end成员函数用于返回一个迭代器，能够指向容器的第一个元素和末端元素的后面，这个容器就可以支持范围for语句

# 39.C和C++的内存分配

前者3个，后者5个

# 40.malloc

malloc一般形式是

void * malloc(int NumBytes)

看下面范例

int * p = NULL;

p = (int *)malloc(10 * sizeof(int));

if(p != NULL)

{

*p = 5; //其实只用到了申请40字节的4个字节

cout << *p <

free(p);

}

new/delete比malloc/free做了更多的工作，所以在C++中用new和delete

# 41.指针的初始化

对于指针的初始化，能用nullptr的全部用nullptr

cout << typeid(NULL).name() << endl; //int

cout << typeid(nullptr).name() << endl; //std::nullptr_t

# 42.struct

```cpp
struct student
{
    private:
        int number;
        void func()
        {
            number++;        
        }
}

student stu1;
stu1.number = 1001 //不可以引用
//不可以通过对象名引用结构或类的成员，否则编译时报错
//但是在成员函数func中还是可以直接引用number的，因为成员函数可以直接访问成员变量而不管成员变量是否为private
```

结构体中默认是public，类中则是private，他们的继承也是
