---
layout: post
title: C++开发经验

---

{{ page.title }}
================

<p class="meta">09 May 2022 - Guangzhou</p>

这篇博客是记录自己从新人小白慢慢成长的过程，内容都是工作中实际遇到的问题。之前是写在有道云笔记上，但随着保存的内容越来越多，自己没怎么回顾，所以干脆写出来加深下记忆

输入输出的时候用 %I64d

scanf(”%I64d”,&a);

printf(”%I64d”,a);

(2) 在linux下的gcc/g++里面，数据类型声明写作

long long a;

输入输出时候用 %lld

(3) 在win下的其它IDE里面[包括高版本Visual Studio]，数据类型声明用上面两种均可

输入输出用 %I64d

**================== 以下可无视 =========================**

以下是对这种混乱情况的解释，如无兴趣可以跳过

首先要说的是，和Java等语言不同，C/C++本身并没有规定各数据类型的位数，只是限定了一个大小关系，也就是规定从所占的bit数来说，short <= int <= long <= long long。至于具体哪种类型占用多少位，是由你所用的开发平台的编译器决定的。在现在的PC上一个通常的标准是，int和long同为32位，long long为64位。但是如果换到其它平台(如ARM)上，这个数字可能会有不同，类型所占的大小可以用sizeof()运算符查看。

long long是C99标准中新引进的数据类型，在古老的VC6.0中并没有这个类型，所以在VC6.0中用”long long”会发生编译错误。为了表示64位整数，VC6里采用的是微软自己搞出来的一个数据类型，叫做__int64，所以如果你是在VC6.0下编译的话，应该用__int64定义64位整型。新版的Visual Studio已经支持long long了。GCC是支持long long的，我们在win系统中使用的其它IDE如Dev-Cpp, Code::Blocks等等大多是采用的MinGW编译环境，它是与GCC兼容的，所以也支持long long（另外为了与MS兼容，也支持__int64）。如果是在纯的linux下，就只能使用long long了。

关于使用printf的输入输出，这里就有一个更囧的情况。实际上只要记住，主要的区分在于操作系统：如果在win系统下，那么无论什么编译器，一律用%I64d；如果在linux系统，一律用%lld。这是因为MS提供的msvcrt.dll库里使用的就是%I64d的方式，尽管Dev-Cpp等在语法上支持标准，但也不得不使用MS提供的dll库来完成IO，所以就造成了这种情况。

**==================== 无视至此 ===========================**

那么对ACMer来说，最为关心的就是在各个OJ上交题应分别使用哪种方式了。其实方式只有有限的几种：

如果服务器是linux系统，那么定义用long long，IO用%lld

如果服务器是win系统，那么声明要针对编译器而定：

\+ 如果用MS系列编译器，声明用__int64 [现在新版的Visual Studio也支持long long了]

\+ 如果用MinGW环境，声明用long long

\+ 无论什么编译器，IO一律%I64d

下面把各大OJ情况列表如下：

\1. TOJ : Linux系统

\2. ZOJ : Linux系统

\3. POJ : Win系统，语言如选择C/C++，则用MS编译器[支持两种声明]，如选择GCC/G++，则为MinGW

\4. UVa : Linux系统

\5. Ural: Win系统，MS编译器[支持两种声明]

\6. SPOJ: Linux系统

\7. SGU : Win系统，MS编译器[支持两种声明]

如果有不太清楚的情况可以先看看各OJ上的FAQ，通常会有说明。

另外，为了避免混乱，当数据量不大时，用cin, cout进行输入输出也是一种选择
