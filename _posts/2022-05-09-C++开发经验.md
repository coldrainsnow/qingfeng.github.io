---
layout: post
title: C++开发经验

---

{{ page.title }}
================

<p class="meta">09 May 2022 - Guangzhou</p>

[TOC]

这篇博客是记录自己从新人小白慢慢成长的过程，内容都是工作中实际遇到的问题。之前是写在有道云笔记上，但随着保存的内容越来越多，自己没怎么回顾，所以干脆写出来加深下记忆 

<br>

---

<br>

# 怎么理解#if #else #endif



其实也按照if else来理解，大概意思是一样的

但是#if #else #endif 他们是在预处理阶段 ，所以判断为真的那部分代码才进行编译

ex:

```c++
#if CAD_VERSION >= 2018
	代码A部分
#else
    代码B部分
#endif
```

仅当预处理阶段判断CAD_VERSION >= 2018时，才采用代码A，否则采用代码B

另外它的使用场景也可以是判断是否为Linux还是Window平台

假如现在要开发一个C语言程序，让它输出红色的文字，并且要求跨平台，在 Windows 和 Linux 下都能运行，怎么办呢？

这个程序的难点在于，不同平台下控制文字颜色的代码不一样，我们必须要能够识别出不同的平台。

Windows 有专有的宏`_WIN32`，Linux 有专有的宏`__linux__`，以现有的知识，我们很容易就想到了 [if else](http://c.biancheng.net/c/if_else/)，请看下面的代码：

```c++
#include <stdio.h>
int main(){
    if(_WIN32){
        system("color 0c");
        printf("http://c.biancheng.net\n");
    }else if(__linux__){
        printf("\033[22;31mhttp://c.biancheng.net\n\033[22;30m");
    }else{
        printf("http://c.biancheng.net\n");
    }
    return 0;
}
```

但这段代码是错误的，在 Windows 下提示 __linux__ 是未定义的标识符，在 Linux 下提示 _Win32 是未定义的标识符。对上面的代码进行改进：

```c++
#include <stdio.h>
int main(){
    #if _WIN32
        system("color 0c");
        printf("http://c.biancheng.net\n");
    #elif __linux__
        printf("\033[22;31mhttp://c.biancheng.net\n\033[22;30m");
    #else
        printf("http://c.biancheng.net\n");
    #endif
    return 0;
}
```

由于在window和linux平台下有时使用的头文件或者处理方法都不太一样，所以会用到它

这些操作都是在预处理阶段完成的，多余的代码以及所有的宏都不会参与编译，不仅保证了代码的正确性，还减小了编译后文件的体积

这种能够根据不同情况编译不同代码、产生不同目标文件的机制，称为条件编译。条件编译是预处理程序的功能，不是编译器的功能

<br>

---

<br>

# MFC中的CString和string的区别

<br>

这个问题总感觉自己总结的有些毛病，等我以后再修改

我平常工作经常见到CString，因为我们是用MFC

注意这里说的是字符串的类，不是头文件<cstring>，MFC中CString的头文件是<afx.h>

下面区分下MFC的CString和<cstring>头文件和std::string

CString 是 MFC 框架特有的类。它提供了许多其他两个类所没有的特性，但是CString 不像其他两个类那样可移植

<cstring>是一个头文件，其中包含一组用于处理以null结尾的字符数组的函数，它是一个非常低级的库，不提供CString和std::string中可用的任何功能，但是<cstring>可移植性强，可以支持任何C++平台使用

std::string是字符串的标准C++类，是比CString更高级的类，提供了很多CString所没有的特性，比如支持宽字符和多种字符编码

一般来说，开发并且仅在window使用需要高级字符串操作的，用CString

开发需要移植并且不需要高级字符串操作的用<cstring>

开发需要可移植且需要高级字符串操作功能的应用程序，则用std::string 

CString一般来说效率更低一些

- **对象创建和销毁开销：**因为CString是个类，牵扯到对象的创建和销毁，每次创建一个CString对象时，会分配一个新的内存块来存储字符串数据，当对象被销毁时，内存被释放。在性能关键型应用程序中，这种开销可能很大，尤其是在频繁创建和销毁字符串的情况下
- **引用计数开销：** CString 使用引用计数系统来管理内存。每当字符串被复制或分配给另一个变量时，该系统通过递增引用计数来工作。每当字符串被销毁时，引用计数就会减少。如果引用计数达到零，则释放字符串的内存。引用计数系统可能效率低下，因为每次修改字符串时都需要额外的簿记操作
- **无法直接访问底层字符数组：** CString 不提供对底层字符数组的直接访问。这意味着复制和连接等操作必须通过 CString 方法执行，这比直接对字符数组执行操作要慢



<br>

---

<br>

# __int 64和long long

<br>

这个问题有个博主写的很详细，我把它摘抄过来。

首先64位整型是C++一直没有确定规范的数据类型，主流编译器对64位整型支持标准也不一样。

__int 64是windows平台专属的，long long则是标准类型。

为啥会有这么混乱呢，因为是C++并没有规定每个数据类型的位数，只规定了一个大小，也就是规定的所占的bit数来说，short <= int <= long <= long long，至于具体什么类型占用多少位，是由自己开发平台的编译器决定的。

long long是C99标准中新引进的数据类型，所以在古老的VC6.0中并没有这个类型，在VC6.0中用”long long”会发生编译错误。

当时为了表示64位整数，微软自己搞了一个叫做int64，所以在VC6.0的话用int64没问题，现在VS也已经支持long long了，GCC也支持long long，平常其他的在window的编译器比如Dev-cpp这些大多数也是采用了MinGW编译环境，是与GCC兼容的，所以也可以long long，但如果在Linux下，只能用long long。

关于使用printf的输入输出，这里就有一个更囧的情况。实际上只要记住，主要的区分在于操作系统：如果在win系统下，那么无论什么编译器，一律用%I64d；如果在linux系统，一律用%lld。这是因为MS提供的msvcrt.dll库里使用的就是%I64d的方式，尽管Dev-Cpp等在语法上支持标准，但也不得不使用MS提供的dll库来完成IO，所以就造成了这种情况。

以下是五种常用的C/C++编译器对64位整型的支持，这五种编译器分别是gcc(mingw32)，g++(mingw32)，gcc(linux i386)，g++(linux i386)，Microsoft Visual C++ 6.0。可惜的是，没有一种定义和输出方式组合，同时兼容这五种编译器。

下面是其他博主为了彻底弄清不同编译器对64位整型，写的程序对它们进行了评测：

<div class="table-wrapper" markdown="block">




| 变量定义  | 输出方式     | gcc(mingw32) | g++(mingw32) | gcc(linux i386) | g++(linux i386) | MicrosoftVisual C++ 6.0 |
| --------- | ------------ | ------------ | ------------ | --------------- | --------------- | ----------------------- |
| long long | “%lld”       | 错误         | 错误         | 正确            | 正确            | 无法编译                |
| long long | “%I64d”      | 正确         | 正确         | 错误            | 错误            | 无法编译                |
| __int64   | “lld”        | 错误         | 错误         | 无法编译        | 无法编译        | 错误                    |
| __int64   | “%I64d”      | 正确         | 正确         | 无法编译        | 无法编译        | 正确                    |
| long long | cout         | 非C++        | 正确         | 非C++           | 正确            | 无法编译                |
| __int64   | cout         | 非C++        | 正确         | 非C++           | 无法编译        | 无法编译                |
| long long | printint64() | 正确         | 正确         | 正确            | 正确            | 无法编译                |



</div>

上表中，正确指编译通过，运行完全正确；错误指编译虽然通过，但运行结果有误；无法编译指编译器根本不能编译完成。观察上表，我们可以发现以下几点：

1. long long定义方式可以用于gcc/g++，不受平台限制，但不能用于VC6.0。
2. __int64是Win32平台编译器64位长整型的定义方式，不能用于Linux。
3. “%lld”用于Linux i386平台编译器，”%I64d”用于Win32平台编译器。
4. cout只能用于C++编译，在VC6.0中，cout不支持64位长整型。

首先是如果我们在自己机器上写程序的话，情况分类如下：

(1) 在win下的VC6.0里面，声明数据类型的时候应该写作

__int64 a;

输入输出的时候用 %I64d

scanf(”%I64d”,&a);

printf(”%I64d”,a);

(2) 在linux下的gcc/g++里面，数据类型声明写作

long long a;

输入输出时候用 %lld

(3) 在win下的其它IDE里面[包括高版本Visual Studio]，数据类型声明用上面两种均可

输入输出用 %I64d

参考链接：

[__int64 与 long long的区别 - felove - 博客园 (cnblogs.com)](https://www.cnblogs.com/felove2013/articles/3880590.html)

