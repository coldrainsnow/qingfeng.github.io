---
layout: post
title: "C++开发经验"
date: 2021-10-14
excerpt: "C++开发经验续篇"
tags: [python, tutorial]
comments: true
---

* TOC
{:toc}

## 怎么理解#if #else #endif

其实也按照if else来理解，大概意思是一样的

但是#if #else #endif 他们是在预处理阶段 ，所以判断为真的那部分代码才进行编译

ex:

```c++
#if CAD_VERSION >= 2018
	代码A部分
#else
    代码B部分
#endif
```

仅当预处理阶段判断CAD_VERSION >= 2018时，才采用代码A，否则采用代码B

另外它的使用场景也可以是判断是否为Linux还是Window平台

假如现在要开发一个C语言程序，让它输出红色的文字，并且要求跨平台，在 Windows 和 Linux 下都能运行，怎么办呢？

这个程序的难点在于，不同平台下控制文字颜色的代码不一样，我们必须要能够识别出不同的平台。

Windows 有专有的宏`_WIN32`，Linux 有专有的宏`__linux__`，以现有的知识，我们很容易就想到了 [if else](http://c.biancheng.net/c/if_else/)，请看下面的代码：

```c++
#include <stdio.h>
int main(){
    if(_WIN32){
        system("color 0c");
        printf("http://c.biancheng.net\n");
    }else if(__linux__){
        printf("\033[22;31mhttp://c.biancheng.net\n\033[22;30m");
    }else{
        printf("http://c.biancheng.net\n");
    }
    return 0;
}
```

但这段代码是错误的，在 Windows 下提示 __linux__ 是未定义的标识符，在 Linux 下提示 _Win32 是未定义的标识符。对上面的代码进行改进：

```c++
#include <stdio.h>
int main(){
    #if _WIN32
        system("color 0c");
        printf("http://c.biancheng.net\n");
    #elif __linux__
        printf("\033[22;31mhttp://c.biancheng.net\n\033[22;30m");
    #else
        printf("http://c.biancheng.net\n");
    #endif
    return 0;
}
```

由于在window和linux平台下有时使用的头文件或者处理方法都不太一样，所以会用到它

这些操作都是在预处理阶段完成的，多余的代码以及所有的宏都不会参与编译，不仅保证了代码的正确性，还减小了编译后文件的体积

这种能够根据不同情况编译不同代码、产生不同目标文件的机制，称为条件编译。条件编译是预处理程序的功能，不是编译器的功能

## #pragma comment是什么

C++中经常有类似这样一行代码

```c++
pragma  comment(lib, "DllTest.lib")
```

\#pragma comment是一个编译器指令，指示 Visual C++ 在生成的对象文件中留下注释。然后，链接器可以在处理目标文件时读取注释
\#pragma comment(lib, "DllTest.lib")告诉链接器将“DllTest.lib”库添加到库依赖项列表中

## 在大型项目中为什么不能用using namespace std

在大型项目中，使用using namespace std;会存在以下几个问题：

1. 命名冲突：使用using namespace std;会将所有std命名空间下的名称都引入当前命名空间，可能会与当前项目中的其他标识符冲突，导致编译错误。
2. 可读性差：如果在项目中使用大量的命名空间，代码可能会变得难以阅读和理解，因为不知道哪个标识符映射到哪个命名空间。
3. 可维护性差：在大型项目中，多人协作开发时，每个人编写的代码都可能使用不同的命名空间。如果在一个文件中使用 using namespace std;，则可能导致其他人的代码出现不可预期的结果，从而影响整个项目的质量。

综上所述，虽然使用using namespace std;可以简化代码，但在大型项目中会带来一些潜在问题，因此最好在每个文件中使用全限定名称。

举一个using namespace std;命名冲突的例子

```
#include <iostream>
using namespace std;

class MyClass {
public:
    int cout;
};

int main() {
    MyClass obj;
    obj.cout = 1;
    cout << "obj.cout = " << obj.cout << endl; // 输出的结果不是预期的
    return 0;
}
```

在这个例子中，我们定义了一个名为MyClass的类，它具有一个名为cout的公共成员变量。当我们使用using namespace std;的时候，它会将命名空间std中的所有名字引入到当前的命名空间中，这就包括了名为cout的输出流对象。因此，在我们的类中访问cout变量将不再是我们定义的变量，而是被重命名为std::cout的输出流对象。这就导致了一个名字冲突，从而编译失败。

如何修改这个代码，让它正确

```
#include <iostream>

class MyClass {
public:
    int cout;
};

int main() {
    MyClass obj;
    obj.cout = 1;
    std::cout << "obj.cout = " << obj.cout << std::endl;
    return 0;
}
```

在这个版本的代码中，我们在使用cout对象时使用了std::cout，而不是直接使用cout。这样就避免了与类中定义的数据成员命名冲突的问题。

## 为什么C++ 中需要运算符重载

运算符重载的主要目的是为了方便程序员使用自定义类型。在某些情况下，C++的内置类型可能无法满足程序的需要，需要使用自定义类型。在这种情况下，合适的操作符重载可以使自定义类型的操作像内置类型一样自然。

运算符重载的另一个目的是提高代码的可读性和可维护性。操作符重载允许我们在代码中使用一些符号，帮助我们表达代码的目的，而无需使用冗长的函数名称。

此外，C++标准库提供了许多用于处理自定义类型的函数和算法，这些函数和算法通常都使用操作符重载。

------

假设我们有一个自定义的Complex类，表示复数。我们想重载运算符以实现复数加法和复数减法。以下是一个简单的例子实现

```
// Complex 类定义 
class Complex {
private:
    double real, imag;
public:
    Complex(double r=0, double i=0) : real(r), imag(i) {};
    Complex operator+(const Complex& c) {
        return Complex(real + c.real, imag + c.imag);
    }
    Complex operator-(const Complex& c) {
        return Complex(real - c.real, imag - c.imag);
    }
    void print() {
        std::cout << "(" << real << "," << imag << ")" << std::endl;
    }
};

// main 函数
int main ()
{
  Complex a(2.0,3.0);
  Complex b(4.0, 5.0);
  Complex c = a + b; // 调用重载运算符实现 a + b
  Complex d = a - b; // 调用重载运算符实现 a - b
  c.print(); // 输出 (6,8)
  d.print(); // 输出 (-2,-2)
  return 0;
}
```

在这个例子中，我们重载了Complex的加号和减号运算符，以便实现两个复数的加法和减法。我们使用运算符“+”来表示复数加法，用运算符“-”表示减法。运算符重载可以使代码更具有可读性和可重用性。

------

**为什么complex operator + (const Complex& c)**

在 C++ 中，使用 const 关键字可以将对象或指针声明为常量，表示它们的值不可更改。在函数形参中使用 const 关键字，可以避免无意修改参数的值，同时可以提高代码的健壮性和可读性。

在 Complex 类的成员函数 operator+ 函数中，const 关键字用于函数参数 const Complex& c 上。这表示函数不会修改传递给它的参数对象 c 本身。

当我们使用 const Complex& 引用时，我们可以避免复制传递的对象，减少了临时创建副本的时间和空间消耗，提高了程序的效率。而且，使用 const 还可以防止意外修改传递的参数值，使得代码更加安全、可靠。

当我们将该运算符作为成员函数时，该函数只有一个参数。这个参数是我们想要重载的运算符右侧的运算值。因此，使用 const Complex & 在参数前表示我们将不会修改这个参数，并且使用 & 表示我们将以引用方式传递参数，从而避免创建副本并减少程序的开销。

总之，在这个例子中，使用 const 关键字可以为该函数提供一个额外的保障，避免了不必要的错误并提高了代码的可维护性和安全性。

## 为什么选用int64_t而不是longlong

int64_t 是 C++ 中的一种整型数据类型，占用 8 个字节（64 位），可以存储的整数范围是从 -9223372036854775808 到 9223372036854775807。它是一种固定长度的数据类型，可以保证在不同的平台上都有相同的位数和取值范围，适用于需要存储大整数的场合。在某些系统中，也可以用 long long int 代替 int64_t。

使用 long long 存储大整数在绝大多数情况下可能是没有问题的，但是在不同的编译器或平台上的实现有可能是不同的，由于 long long 的长度没有明确定义，可能只占有 4 个字节（32 位），而在一些应用场景需要确保整数类型占用的字节数和范围。这就是为什么对于大整数我们会选择使用 int64_t 类型的原因，它是一个标准的、固定长度的整数类型。

那有什么场景是只能用longlong而不能用int64_t的呢

> 在某些不使用补码表示的嵌入式系统中，C++编译器可能不存在 int64_t 类型。此外，如果在其他程序库、运行环境等上下文中定义了某个名为 int64_t 的实体，那么使用 long long 代替 int64_t 可能更明确和安全。

补充问题：int64_t和longlong和__int64

- int64_t是C99标准引入的一种数据类型，可以实现跨平台的可移植性。在32位和64位系统中都使用同一种大小和字节序。该类型定义在<stdint.h>头文件中。
- long long是C99和C++11中的一种基本类型，用于表示64位整数。需要注意的是，该类型并不是在所有平台上都实现为64位的整型，具体实现可以参考编译器文档。
- __int64是Microsoft Visual C++编译器所支持的一种扩展整型类型，用于定义一个有符号64位整型变量。它仅在Microsoft Visual C++编译器中有效，可能不具有跨平台的可移植性。

因此，如果要实现跨平台的可移植性，应该使用int64_t类型。如果使用Microsoft Visual C++编译器，则可以使用__int64类型。而long long可以在大多数情况下使用，但在某些特定平台上可能会与定义不符。
