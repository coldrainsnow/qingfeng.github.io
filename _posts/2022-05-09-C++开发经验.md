---
layout: post
title: "C++开发经验"
date: 2021-10-14
excerpt: "C++开发经验续篇"
tags: [python, tutorial]
comments: true
---

[TOC]

## 怎么理解#if #else #endif

其实也按照if else来理解，大概意思是一样的

但是#if #else #endif 他们是在预处理阶段 ，所以判断为真的那部分代码才进行编译

ex:

```c++
#if CAD_VERSION >= 2018
	代码A部分
#else
    代码B部分
#endif
```

仅当预处理阶段判断CAD_VERSION >= 2018时，才采用代码A，否则采用代码B

另外它的使用场景也可以是判断是否为Linux还是Window平台

假如现在要开发一个C语言程序，让它输出红色的文字，并且要求跨平台，在 Windows 和 Linux 下都能运行，怎么办呢？

这个程序的难点在于，不同平台下控制文字颜色的代码不一样，我们必须要能够识别出不同的平台。

Windows 有专有的宏`_WIN32`，Linux 有专有的宏`__linux__`，以现有的知识，我们很容易就想到了 [if else](http://c.biancheng.net/c/if_else/)，请看下面的代码：

```c++
#include <stdio.h>
int main(){
    if(_WIN32){
        system("color 0c");
        printf("http://c.biancheng.net\n");
    }else if(__linux__){
        printf("\033[22;31mhttp://c.biancheng.net\n\033[22;30m");
    }else{
        printf("http://c.biancheng.net\n");
    }
    return 0;
}
```

但这段代码是错误的，在 Windows 下提示 __linux__ 是未定义的标识符，在 Linux 下提示 _Win32 是未定义的标识符。对上面的代码进行改进：

```c++
#include <stdio.h>
int main(){
    #if _WIN32
        system("color 0c");
        printf("http://c.biancheng.net\n");
    #elif __linux__
        printf("\033[22;31mhttp://c.biancheng.net\n\033[22;30m");
    #else
        printf("http://c.biancheng.net\n");
    #endif
    return 0;
}
```

由于在window和linux平台下有时使用的头文件或者处理方法都不太一样，所以会用到它

这些操作都是在预处理阶段完成的，多余的代码以及所有的宏都不会参与编译，不仅保证了代码的正确性，还减小了编译后文件的体积

这种能够根据不同情况编译不同代码、产生不同目标文件的机制，称为条件编译。条件编译是预处理程序的功能，不是编译器的功能

## MFC中的CString和string的区别

这个问题总感觉自己总结的有些毛病，等我以后再修改

我平常工作经常见到CString，因为我们是用MFC

注意这里说的是字符串的类，不是头文件<cstring>，MFC中CString的头文件是<afx.h>

下面区分下MFC的CString和<cstring>头文件和std::string

CString 是 MFC 框架特有的类。它提供了许多其他两个类所没有的特性，但是CString 不像其他两个类那样可移植

<cstring>是一个头文件，其中包含一组用于处理以null结尾的字符数组的函数，它是一个非常低级的库，不提供CString和std::string中可用的任何功能，但是<cstring>可移植性强，可以支持任何C++平台使用

std::string是字符串的标准C++类，是比CString更高级的类，提供了很多CString所没有的特性，比如支持宽字符和多种字符编码

一般来说，开发并且仅在window使用需要高级字符串操作的，用CString

开发需要移植并且不需要高级字符串操作的用<cstring>

开发需要可移植且需要高级字符串操作功能的应用程序，则用std::string 

CString一般来说效率更低一些

- **对象创建和销毁开销：**因为CString是个类，牵扯到对象的创建和销毁，每次创建一个CString对象时，会分配一个新的内存块来存储字符串数据，当对象被销毁时，内存被释放。在性能关键型应用程序中，这种开销可能很大，尤其是在频繁创建和销毁字符串的情况下
- **引用计数开销：** CString 使用引用计数系统来管理内存。每当字符串被复制或分配给另一个变量时，该系统通过递增引用计数来工作。每当字符串被销毁时，引用计数就会减少。如果引用计数达到零，则释放字符串的内存。引用计数系统可能效率低下，因为每次修改字符串时都需要额外的簿记操作
- **无法直接访问底层字符数组：** CString 不提供对底层字符数组的直接访问。这意味着复制和连接等操作必须通过 CString 方法执行，这比直接对字符数组执行操作要慢

## __int 64和long long

这个问题有个博主写的很详细，我把它摘抄过来。

首先64位整型是C++一直没有确定规范的数据类型，主流编译器对64位整型支持标准也不一样。

__int 64是windows平台专属的，long long则是标准类型。

