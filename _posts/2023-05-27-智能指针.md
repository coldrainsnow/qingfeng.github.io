---
layout: post
title: "智能指针"
date: 2023-05-27
excerpt: "从0开始剖析智能指针"
tags: [cpp]
comments: true


---

## 实现简易智能指针

```c++
#include<iostream>
using namespace std;

// 智能指针 保证能做到资源的自动释放
// 智能指针实际利用栈上的对象出作用域自动析构的特征，来做到资源的自动释放
// 因为裸指针是个堆，所以需要手动释放对象，现在写成类后，就可以用栈来自动释放对象了
template<typename T>
class CSmartPtr
{
public:
	CSmartPtr(T *ptr = nullptr)
		:mptr(ptr) {}
	~CSmartPtr() { delete mptr; }

	T& operator*() { return *mptr; } //必须是T&，否则不能修改mptr指向的对象的值，反而是会创建一个临时副本，把值传给临时副本，而不是原对象
	T* operator->() { return mptr; }
private:
	T *mptr;
};

int main()
{
	CSmartPtr<int> ptrl(new int);
	*ptrl = 20;// 这一行使用了重载的解引用运算符来访问 ptrl 所管理的 int 对象，并将其值设置为 20。

	class Test
	{
	public:
		void test() { cout << "call Test::test" << endl; }
	};
	CSmartPtr<Test> ptr2(new Test());
	// (ptr2->operator->())->test();
	ptr2->test();
	
	return 0;
}

// 智能指针放在堆上
// CSmartPtr<int> *p = new CSmartPtr<int>(new int); delete p;这时候p是指向堆的智能指针，所以也要手动释放，这样就没啥意义了，还不如直接使用裸指针
// 在这段代码中，p 是一个指向 CSmartPtr<int> 类型的指针。*p 是一个 CSmartPtr<int> 类型的对象。
// 在这里，new int 是一个表达式，它使用 new 运算符动态分配内存来存储一个 int 类型的对象，并返回一个指向该对象的指针。这个指针被传递给 CSmartPtr<int> 的构造函数作为参数
```



## 问题

我们继续看下面的代码

```cpp
CSmartPtr<int> p1(new int);
CSmartPtr<int> p2(p1);
```

这样的话，是会报错的，因为这会造成一个浅拷贝的问题（等以后再详细解释

那么为了解决浅拷贝的问题，我们用不带引用计数的智能指针和带引用计数的智能指针来解决



## 不带引用计数的智能指针

不带引用计数的：是只能一个指针管理资源

auto_ptr:C++库里面的

C++11新标准：scoped_ptr和unique_ptr



首先说auto_ptr

```cpp
auto_ptr<int> p1(new int);
auto_ptr<int> p2(p1);
```

这样是可以正确运行的

但我们继续

```cpp
auto_ptr<int> p1(new int);
auto_ptr<int> p2(p1);
*p2 = 20;
cout << *p1 << endl;
```

这是会报错的，那为什么呢，p1和p2不都是指向同一块内存吗

这时候咱们可以看下auto_ptr的拷贝构造函数看看了

```cpp
auto_ptr(auto_ptr& _Right) noexcept : _Myptr(_Right.release()) {}
```

```cpp
_Ty* release() noexcept {
        _Ty* _Tmp = _Myptr;
        _Myptr    = nullptr;
        return _Tmp;
    }
```

_Right就是咱们传入的p1了，p1调用release后，返回值初始化p2，在源代码里其实就是\_Myptr，\_Myptr查看源码，它是成员变量，也就是auto_ptr封装的裸指针

```cpp
private:
    _Ty* _Myptr; 
```

其实auto_ptr在里面是这样走的，首先是把当前指针p1咱们的值先记下来，然后把当前指针p1改成nullptr，最后再把原来的值返回回去给p2

你把上面源代码release中的_Myptr换成p1就好理解了

但这样就带来了一个问题，那就是auto_ptr每次都是只记住最后一个指针，前面的指针都为空了

但我们的本意是想让p1和p2都可以访问到这个地址，所以这样说的话auto_ptr是有些问题的，所以你也能看到一般也都是不推荐使用auto_ptr

经常会被问到能不能再容器当中使用auto_ptr，其实尽量是别搞

```cpp
vector<auto_ptr<int>> vec1;
vec2(vec1);
```

因为容器在使用过程中，难免会用到容器的拷贝构造或者容器的赋值，而这样的话，会影响容器内每个元素的拷贝赋值

当你用vec1构造vec2的时候，那就说明vec1里面的指针，全部为空，当你在不知道这个的情况下，你使用vec1里面的智能指针，就全部都是空指针了



既然auto_ptr尽量不用，那scoped_ptr呢

我们先看scoped_ptr的拷贝构造函数和拷贝赋值运算符

```cpp
scoped_ptr(const scoped_ptr<T>&) = delete;
scoped_ptr<T>& operator=(const scoped_ptr<T>&) = delete;  
```

这些语句定义了scoped_ptr的拷贝构造函数和拷贝赋值运算符，它们使用了C++11中的关键字来禁用了这些函数

这意味着你不能使用拷贝构造函数或拷贝赋值运算符来创建一个 scoped_ptr对象的副本，如果你尝试这样做，编译器将报错

其实scoped_ptr的拷贝构造函数是被声明为private并且是没被定义的，这意味着你不能使用拷贝构造函数来创建一个 scoped_ptr对象的副本

这是为了防止多个 scoped_ptr对象管理同一个资源，从而避免在其中一个 scoped_ptr对象销毁时释放资源，导致其他 scoped_ptr 对象悬空

所以 scoped_ptr就不能这样写，这样写就是错的

```cpp
scoped_ptr<int> p1(new int);
scoped_ptr<int> p2(p1);  
```



那该怎么办呢，也就只剩下unique_ptr了

我们看它的拷贝构造函数和拷贝赋值运算符

```cpp
unique_ptr(const unique_ptr<T>&) = delete;
unique_ptr<T>& operator=(const unique_ptr<T>&) = delete;  
```

和上面scoped_ptr是一样的，那说明我们这样写也是错的

```cpp
unique_ptr<int> p1(new int);
unique_ptr<int> p2(p1);  
```

但是如果这样写呢

```cpp
unique_ptr<int> p1(new int);
unique_ptr<int> p2(std::move(p1)); 
```

运行后发现是可以的，那是为什么呢

再看它的源码

发现提供了类似这样的函数

```cpp
unique_ptr(unique_ptr &&src)
unique_ptr<T>& operator=(unique_ptr<T> &&src) 
```

这是两个右值引用，简单介绍下右值引用吧

> 右值引用是 C++11 中引入的一种新类型的引用，它绑定到右值（临时对象或将要销毁的对象）上。右值引用通常用于实现移动语义和完美转发。
>
> 右值引用使用 `&&` 符号来声明。例如，下面的代码声明了一个 `int` 类型的右值引用：
>
> ```c++
> int&& rvalue_ref = 5;
> ```
>
> 在这段代码中，我们将一个右值（字面量 `5`）绑定到一个右值引用上。
>
> 你可以使用 `std::move` 函数将左值转换为右值引用。例如，下面的代码声明了一个 `int` 类型的变量，并将其转换为右值引用：
>
> ```c++
> int x = 5;
> int&& rvalue_ref = std::move(x);
> ```
>
> 在这段代码中，我们使用 `std::move` 函数将左值 `x` 转换为右值引用，并将其绑定到一个右值引用上。
>
> 需要注意的是，使用 `std::move` 函数并不会移动对象或释放资源。它只是将左值转换为右值引用，以便可以使用移动构造函数或移动赋值运算符来转移对象的所有权。

所以你可以把代码连起来看

```cpp
unique_ptr(unique_ptr &&src)
unique_ptr<T>& operator=(unique_ptr<T> &&src) 
unique_ptr<int> p1(new int);
unique_ptr<int> p2(std::move(p1)); 
```

unique_ptr(unique_ptr &&src) 是unique的移动构造函数，它接收一个右值引用作为参数。当你使用std::move函数将一个unique_ptr对象转化为右值引用并将其传递给另一个unique_ptr对象来初始化时，就会调用这个构造函数

unique_ptr<T>& operator=(unique_ptr<T> &&src) 是unique_ptr的构造赋值运算符，它也接收一个右值引用作为参数。当你使用std::move函数将一个unique_ptr对象转化为右值引用并将其赋值给另一个unique_ptr对象来初始化时，就会调用这个运算符

第三行代码创建一个unique_ptr\<int\>对象p1，并且使用new int动态分配内存来存储一个int类型的对象

第四行代码创建另一个unique_ptr\<int\>对象p2，并且使用std::move()将p1转化为右值引用并传递给p2的移动构造函数，这样p1的所有权转移给p2，p1变为空指针

三四行代码，不涉及构造赋值运算符，只涉及到移动构造函数



这时候肯定会说，那和auto_ptr也一样啊，但unique_ptr\<int\> p2(std::move(p1)); 的优点在于你知道p1是把所有权转移给了p2（毕竟看到了move），但是auto_ptr你可能都没意识到



## 带引用计数的智能指针

带引用计数：多个指针可以同时管理同一个资源

给每一个对象资源，匹配一个引用计数，当智能指针使用这个资源的时候，引用计数+1，不使用资源的时候，引用计数-1

如果发现这个资源的引用计数为0，说明是最后一个使用这个资源的指针，所以就给它释放掉了

看下面的代码

```cpp
#include<iostream>
#include <memory>
using namespace std;

// 对资源进行引用计数的类
template<typename T>
class RefCnt // 重新设置count
{
public:
	RefCnt(T* ptr = nullptr)
		:mptr(ptr)
	{
		if (mptr != nullptr)
		{
			mcount = 1;
		}
	}
	void addRef() { mcount++; } // 增加资源的引用计数
	int delRef() { return --mcount; }
private:
	T* mptr;
	int mcount; // 实际sharedptr里面这个是用atomic_int CAS 原子正项位，是保证了加加减减线程安全
};

// 智能指针 保证能做到资源的自动释放
// 利用栈上的对象出作用域自动析构的特征，来做到资源的自动释放
// 因为裸指针是个堆，所以需要手动释放对象，现在写成类后，就可以用栈来自动释放对象了
template<typename T>
class CSmartPtr	// shared_ptr类似，但是我们这里没有考虑多线程因为mcount加加减减的  shared_ptr和weak_ptr都是线程安全，可以直接使用在多线程环境下
{
public:
	CSmartPtr(T *ptr = nullptr)
		:mptr(ptr) 
	{
         // 它创建一个新的RefCnt对象，并使用mptr作为参数来初始化它。然后，它将新创建的RefCnt对象的地址赋值给mpRefCnt成员变量
		mpRefCnt = new RefCnt<T>(mptr);
	}
	~CSmartPtr() 
	{ 
		if (0 == mpRefCnt->delRef())
		{
			delete mptr;
			mptr = nullptr;
		}
		
	}

	T& operator*() { return *mptr; } //必须是T&，否则不能修改mptr指向的对象的值，反而是会创建一个临时副本，把值传给临时副本，而不是原对象
	T* operator->() { return mptr; }

    // 拷贝构造函数
	CSmartPtr(const CSmartPtr<T>& src)
		:mptr(src.mptr), mpRefCnt(src.mpRefCnt)
	{
		if (mptr != nullptr)
			mpRefCnt->addRef();
		
	}
	CSmartPtr<T>& operator = (const CSmartPtr<T>& src)
	{
		if (this == &src)
			return *this;
		if (0 == mpRefCnt->delRef())
		{
			delete mptr;
		}

		mptr = src.mptr;
		mpRefCnt = src.mpRefCnt;
		mpRefCnt->addRef();
		return *this;
	}
private:
	T *mptr; // 指向该资源的指针
	RefCnt<T> *mpRefCnt; // 指向该资源引用计数对象的指针
};



int main()
{
	CSmartPtr<int> ptr1(new int);
	CSmartPtr<int> ptr2(ptr1);
	CSmartPtr<int> ptr3;
	ptr3 = ptr2;

	*ptr1 = 20;
	cout << "ptr2:" << *ptr2 << endl;
	cout << "ptr3:" << *ptr3 << endl;

	return 0;
}
```









